select pg_reload_conf();

-- search path
alter database homeaccounting set search_path = '$user,test';
set search_path='test';
show search_path;

-- tables 
create table konto(
	id							smallint primary key generated by default as identity,
	name						varchar(30) not null unique -- why not primary key? because name shall be changable without having to rearrange buchungen
);
-- cache kontostand each month so we don't have to recompute every single buchung every time
create table saldo(
	konto						smallint not null references konto(id),
	time_of_transfer			timestamp(0) not null default current_timestamp,
	haben_in_cents				integer not null default 0, -- because we only do addition, no need to worry about exactness of floating points operations
	soll_in_cents				integer not null default 0, -- because we only do addition and subtraction, no need to worry about exactness of floating points operations
	primary key (konto, time_of_transfer)
);
create index on saldo (time_of_transfer);

create table buchung(
	id								integer primary key generated by default as identity,
	amount							integer not null, --because we only do addition and subtraction, no need to worry about exactness of floating points operations
	source_konto					smallint not null references konto(id),
	source_konto_is_on_haben_side	boolean not null default true, -- otherwise it's Soll
	description						varchar(100),
	time_of_transfer				timestamp(0) not null default current_timestamp
);
create index on buchung (time_of_transfer);

-- needs to be extra table for splitting to several targets
create table buchung_target(
	buchung_id		integer not null references buchung(id),
	amount			integer not null, -- the part of the overall amount that goes to this target_konto
	target_konto	smallint not null references konto(id),
	description		varchar(100),
	primary key (buchung_id, target_konto) -- splitting: the amount from source can be split to several target kontos
);

create table test.test_result(
	test_name 			varchar(50) primary key,
	passed 				boolean
);

create table test.test_error(
	test_name		varchar(50) references test_result(test_name),
	error_message	varchar(250),
	primary key (test_name, error_message)
);

with only_one_buchung as (
        select count(*) != 1 as is_error, 'Expected count of buchung to be 1, actual: ' || count(*) as error_message from app.buchung
    ),
    errors as (
        select * from only_one_buchung where is_error = true
    )
    insert into test.test_error(test_name, error_message)
    select 'Split onto several soll-konten', error_message from errors;

create table test.test_performance_result(
	test_name			varchar(50) primary key references test_result(test_name),
	time_in_millis		bigint
);

drop table test.test_result cascade;

drop table saldo cascade;
alter table buchung drop constraint buchung_target_konto_fkey;
drop table konto cascade;
drop table buchung;
drop table buchung_target cascade;

-- test inserts
insert into konto(name) values ('anc');
insert into saldo(konto, time_of_transfer, haben_in_cents, soll_in_cents) values 
(23, '2024-07-01 00:00:00.000', 4204, 202);

-- queries
select * from konto;
select * from saldo;
select * from buchung;
select * from buchung_target;
select * from pg_authid;
select * from pg_stat_activity;
select * from pg_database;

select * from test_result;

call test.run_unit_tests();
